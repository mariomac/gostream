package iters

import (
	"iter"
)

// Generate an infinite iter.Seq where each element is generated by the provided supplier function.
// Due to the potential statefulness of the supplier, multiple operations towards the same iter.Seq might provide
// different results.
//
// This creates a lazy sequence. The supplier won't be called until it is requested for consumption by
// the transformation or aggregation functions.
//
// Caution! Unless you limit the lenght of the iter.Seq (e.g. using the Limit function), the aggregation
// functions over this iter.Seq might not terminate.
func Generate[T any](supplier func() T) iter.Seq[T] {
	return func(yield func(T) bool) {
		for yield(supplier()) {
		}
	}
}

// Iterate returns an infinite sequential ordered iter.Seq produced by iterative application of a function
// f to an initial element seed, producing a iter.Seq consisting of seed, f(seed), f(f(seed)), etc.
// The first element (position 0) in the iter.Seq will be the provided seed. For n > 0, the element at
// position n, will be the result of applying the function f to the element at position n - 1.
// Due to the stateful nature of the supplier, multiple operations towards the same iter.Seq might provide
// different results.
func Iterate[T any](seed T, f func(T) T) iter.Seq[T] {
	return func(yield func(T) bool) {
		lastElement := seed
		for yield(lastElement) {
			lastElement = f(lastElement)
		}
	}
}

// Concat creates a lazily concatenated iter.Seq whose elements are all the elements of the first iter.Seq
// followed by all the elements of the second iter.Seq.
func Concat[T any](a, b iter.Seq[T]) iter.Seq[T] {
	return func(yield func(T) bool) {
		for i := range a {
			if !yield(i) {
				return
			}
		}
		for i := range b {
			if !yield(i) {
				return
			}
		}
	}
}

// Empty returns an empty iter.Seq
func Empty[T any]() iter.Seq[T] {
	return func(_ func(T) bool) {}
}

// Keys returns an iter.Seq that iterates the keys (first/left items) of the source iter.Seq2
func Keys[K, V any](source iter.Seq2[K, V]) iter.Seq[K] {
	return func(yield func(K) bool) {
		for k := range source {
			if !yield(k) {
				return
			}
		}
	}
}

// Values returns an iter.Seq that iterates the values (second/right items) of the source iter.Seq2
func Values[K, V any](source iter.Seq2[K, V]) iter.Seq[V] {
	return func(yield func(V) bool) {
		for _, v := range source {
			if !yield(v) {
				return
			}
		}
	}
}
